/// tonic_hello_server.rs (Server)

// Declare the module generated by tonic-build.
// The path depends on the package name in your .proto file (helloworld).
mod helloworld {
    tonic::include_proto!("helloworld");
}

use helloworld::greeter_server::{Greeter, GreeterServer};
use helloworld::{HelloReply, HelloRequest};
use std::net::SocketAddr;
use tonic::{Request, Response, Status};

// Define a struct to hold our service implementation.
#[derive(Default)]
pub struct MyGreeter;

// Implement the generated Greeter trait for our struct.
#[tonic::async_trait]
impl Greeter for MyGreeter {
    // The SayHello method implementation.
    async fn say_hello(
        &self,
        request: Request<HelloRequest>, // The incoming request
    ) -> Result<Response<HelloReply>, Status> {
        // The result of the RPC call
        println!("Got a request: {:?}", request);

        // Extract the name from the request message.
        let name = &request.get_ref().name;
        // Create the response message.
        let message = format!("Hello {}!", name);

        // Create the response reply.
        let reply = HelloReply { message };

        // Return the response wrapped in a Result and Response.
        Ok(Response::new(reply))
    }
}

type MainFn = fn() -> Result<(), Box<dyn std::error::Error>>;

// The main function where the server is started.
#[tokio::main]
async fn hello_server() -> Result<(), Box<dyn std::error::Error>> {
    // Define the address for the server to listen on.
    let addr: SocketAddr = "[::1]:50051".parse()?;
    // Create an instance of our service implementation.
    let greeter = MyGreeter::default();

    println!("GreeterServer listening on {}", addr);

    // Start the Tonic server using the builder pattern.
    // The serve().await? expression returns Result<(), Box<dyn std::error::Error>>
    // which matches the function's return type.
    tonic::transport::Server::builder() // Get a server builder
        .add_service(GreeterServer::new(greeter)) // Add our service to the builder
        .serve(addr) // Bind the server to the address and serve incoming requests
        .await?; // Wait for the server to stop or for an error to occur

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[ignore = "tonic grpc server"]
    #[test]
    fn test_hello_server() {
        hello_server().unwrap();
    }
}
