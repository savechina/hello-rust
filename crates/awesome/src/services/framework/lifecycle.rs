use async_trait::async_trait;
use std::sync::Arc;
use tokio::sync::{oneshot, RwLock};
use tokio::task::JoinHandle;
use tracing::{error, info, instrument};
use uuid::Uuid;

use super::{
    config::{BaseServiceConfig, ServiceConfig as TraitServiceConfig},
    consul::{AgentServiceRegistration, ConsulClient}, // Import Consul structs
    error::FrameworkError,
};

/// Represents the current operational status of a service.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ServiceStatus {
    Initializing,
    Starting,
    Running,
    Stopping,
    Stopped,
    Failed(String), // Includes a reason for failure
}

/// The core trait for any runnable application service.
/// Services implementing this trait can be managed by the ApplicationFramework.
#[async_trait]
pub trait RunnableService: Send + Sync + 'static {
    /// The specific configuration type for this service.
    type Config: TraitServiceConfig;

    /// Creates a new instance of the service.
    /// `instance_id` is a unique ID generated by the framework.
    /// `status_arc` provides a shared reference to update the service's status.
    fn new(
        config: Self::Config,
        instance_id: String,
        status_arc: Arc<RwLock<ServiceStatus>>,
    ) -> Self;

    /// Returns the unique instance ID of the service.
    fn instance_id(&self) -> &str;

    /// Returns a clone of the shared status Arc.
    fn get_status_arc(&self) -> Arc<RwLock<ServiceStatus>>;

    /// The main async logic for the service.
    /// It should run indefinitely until `shutdown_rx` receives a signal or a fatal error occurs.
    /// This method is responsible for its own setup (e.g., gRPC server, HTTP server)
    /// and teardown (e.g., graceful shutdown of internal components).
    async fn start_service_logic(
        &self,
        shutdown_rx: oneshot::Receiver<()>,
    ) -> Result<(), FrameworkError>;
}

/// The main framework manager for an application service.
/// It orchestrates the lifecycle (start, stop, status query) of a `RunnableService`.
pub struct ApplicationFramework<S>
where
    S: RunnableService,
{
    service_instance: Arc<S>,
    status_receiver: Arc<RwLock<ServiceStatus>>,
    shutdown_tx: Option<oneshot::Sender<()>>,
    service_handle: Option<JoinHandle<Result<(), FrameworkError>>>,
}

impl<S> ApplicationFramework<S>
where
    S: RunnableService,
{
    /// Creates and starts the application service within the framework.
    #[instrument(name = "framework_start", skip(config), fields(service_name = config.base_config().service_name))]
    pub fn new(config: S::Config) -> Result<Self, FrameworkError> {
        let instance_id = format!(
            "{}-{}",
            config.base_config().service_id_prefix,
            Uuid::new_v4()
        );
        let status_arc = Arc::new(RwLock::new(ServiceStatus::Initializing));
        let (tx_shutdown, rx_shutdown) = oneshot::channel();

        info!(
            "Initializing service '{}' with ID '{}'",
            config.base_config().service_name,
            instance_id
        );

        let service_instance = Arc::new(S::new(config, instance_id, Arc::clone(&status_arc)));
        let service_for_task = Arc::clone(&service_instance); // Clone for the spawned task

        // Spawn the service's main logic as a background task
        let service_handle = tokio::spawn(async move {
            let instance_id_clone = service_for_task.instance_id().to_string();
            let status_arc_clone = service_for_task.get_status_arc();

            // Set status to Starting before calling start_service_logic
            {
                let mut status_guard = status_arc_clone.write().await;
                *status_guard = ServiceStatus::Starting;
                info!(
                    "Service '{}' status: {:?}",
                    instance_id_clone, *status_guard
                );
            }

            // Execute the service's core logic
            let result = service_for_task.start_service_logic(rx_shutdown).await;

            // Update final status based on result
            {
                let mut status_guard = status_arc_clone.write().await;
                match &result {
                    Ok(_) => {
                        *status_guard = ServiceStatus::Stopped;
                        info!(
                            "Service '{}' gracefully stopped. Final status: {:?}",
                            instance_id_clone, *status_guard
                        );
                    }
                    Err(e) => {
                        *status_guard = ServiceStatus::Failed(e.to_string());
                        error!(
                            "Service '{}' stopped with error. Final status: {:?}",
                            instance_id_clone, *status_guard
                        );
                    }
                }
            }
            result
        });

        Ok(Self {
            service_instance,
            status_receiver: status_arc,
            shutdown_tx: Some(tx_shutdown),
            service_handle: Some(service_handle),
        })
    }

    /// Gets the current status of the managed service.
    #[instrument(name = "get_status", skip(self))]
    pub async fn get_status(&self) -> ServiceStatus {
        let status_guard = self.status_receiver.read().await;
        status_guard.clone()
    }

    /// Sends a shutdown signal to the service and waits for it to terminate.
    #[instrument(name = "framework_stop", skip(self))]
    pub async fn stop(&mut self) -> Result<(), FrameworkError> {
        info!(
            "Sending shutdown signal to service '{}'.",
            self.service_instance.instance_id()
        );
        if let Some(tx) = self.shutdown_tx.take() {
            let _ = tx.send(()); // Ignore error if receiver is dropped
        }

        if let Some(handle) = self.service_handle.take() {
            handle
                // .context("Service task failed to join or panicked")?
                .await
                .map_err(|e| FrameworkError::JoinError(e))?;
        }
        Ok(())
    }

    /// Provides access to the underlying `RunnableService` instance.
    pub fn service(&self) -> Arc<S> {
        Arc::clone(&self.service_instance)
    }
}

// --- Common Consul API Structs for Framework Use ---
// These are duplicated from consul.rs for clarity within this file,
// but in a real project, they'd be imported from consul.rs.
// Or, if used only by framework, they could live here.
// For the sake of not having circular dependencies when defining consul.rs,
// they are placed in consul.rs and imported here.
